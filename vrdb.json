[
    {
        "Name": "Abuse of Functionality",
        "Description": "Abuse of functionality, sometimes referred to as a 'business logic attack', depends on the design and implementation for application functions and features. As functionality is added to applications, thought must be given to how the function or feature can be manipulated to circumvent the business process, or abused to perform a function not intended by the developer.",
        "Implication": "An attacker can abuse the functionality within the application to perform undesired actions.",
        "Solution": "Robust threat modeling exercises should be performed for each application feature to enumerate ways that attackers can abuse the feature. All functions and features of the application should be tested against a comprehensive set of use and abuse cases to ensure that the application enables only the intended functionality and no more.",
        "Likelihood": "MEDIUM",
        "Impact": "MEDIUM",
        "Risk": "MEDIUM",
        "Types": "Web"
    },
    {
        "Name": "Application Misconfiguration",
        "Description": "Software applications are very complex; to ease installation and configuration of the application, many software packages come preconfigured with vulnerabilities right out of the box. Application misconfigurations are not coding issues. They are options and/or features in the application that can be easily exploited, such as: Special access mechanisms Default usernames and passwords Default configuration file settings Security settings at the lowest possible level Due to the complexity of configuration, certain combinations of settings might expose vulnerabilities, though each individual setting may be safe on its own.",
        "Implication": "An attacker can leverage poor configurations to get a large amount of attack surfaces, such as insufficient authorization (default credentials), or sniff traffic (running with non-encrypted network traffic).",
        "Solution": "All application permissions, configurable components and files should be given least privilege for the specific platform and technology stack. The application should prominently warn users/administrators when an insecure setting is in use (as it might be temporarily during deployment or in a staging environment).",
        "Likelihood": "MEDIUM",
        "Impact": "MEDIUM",
        "Risk": "MEDIUM",
        "Types": [
            "Web",
            "Thick",
            "Network"
        ]
    },
    {
        "Name": "Brute Force Login",
        "Description": "The application does not prevent attackers from trying many username/password combinations in rapid succession in order to guess account credentials.",
        "Implication": "Attackers may be able to discover valid credentials.",
        "Solution": "The framework should track failed login attempts even for non-existent accounts, so that the lockout feature doesn't expose an account enumeration vulnerability. The framework should track all unique accounts tried unsuccessfully for a particular password, using a hash of the password with a static salt as a key to prevent password exposure. When the threshold is reached, the application should prevent all logins using that password to any account, much like the account lockout. The framework should be capable of sending notifications to perimeter technologies to help enforce lockouts or global CAPTCHA. The lockout period should only be temporary, so as to prevent long-term denial of service against a user account. The framework should provide an interface for an administrator or customer service representative to white-list IPs for an account to log in from, in case of a targeted, sustained, long-term denial of service attack against a specific user. The framework should expose and implement configurable rules about failed login attempts with secure defaults.",
        "Likelihood": "LOW",
        "Impact": "HIGH",
        "Risk": "MEDIUM",
        "Types": "Web"

    },
    {
        "Name": "Brute Force (generic) / Insufficient Anti-automation",
        "Description": "Applications do not define or detect when request rates are outside the bounds of normal, acceptable use.",
        "Implication": "Depending on what is being automated, an attacker may be able to send tons of requests that notify users, fill a database with data, or hog system resources.",
        "Solution": "Perimeter technologies including geocaching/proxy services must support automatic and/or manual 'panic button' anti-automation, enforcing progressive CAPTCHA for unvalidated requests, triggering on excessive 5XX responses, or direct signal from application.",
        "Likelihood": "LOW",
        "Impact": "MEDIUM",
        "Risk": "LOW",
        "Types": [
            "Web",
            "Thick"
        ]
    },
    {
        "Name": "Brute Force Session Identifier",
        "Description": "Session tokens are generated in a predictable fashion or from a key space that is too small to prevent guessing a token in reasonable time. The application does not detect and prevent session brute forcing attempts.",
        "Implication": "Attackers may be able to guess session identifiers, and then be authenticated as another user. This would allow the attacker to act as another user.",
        "Solution": "Ensure that session identifiers are created using a secure random algorithm, with enough entropy to make guessing infeasible during the average lifetime of a session. The framework should check that an active session does not already exist with the same ID as a newly generated session token before issuing the token. The application should be configurable to tie session IDs to SSL sessions, tracking those sessions across renegotiations. Any token which is sent over an SSL connection that isn't currently tied to the token should be expired immediately and the associated session terminated or suspended until the client successfully reauthenticates. The application should be configurable to tie session IDs to source IP addresses, and terminate/suspend any active session if subsequent requests originate from a different IP. The configuration should allow the setting to be enabled globally, or on a per-user or per-session basis. (Users may choose to 'opt in' to the restriction if they know their IP address is unlikely to change during the session.) The application should track the number of requests made with invalid/expired session IDs and alert or block requests based on a configurable rate limit. Malicious actors may be identified by source IP address, a combination of browser fingerprinting features, or other configurable fraud metrics.",
        "Likelihood": "MEDIUM",
        "Impact": "HIGH",
        "Risk": "HIGH",
        "Types": "Web"

    },
    {
        "Name": "Brute Force Predictable Resource Location",
        "Description": "Server-side resources including admin pages, file backups, uploaded files, logs, and sample files exist in easy-to-guess locations. Data resources are often referenced by their auto-incremented primary key, making it easy for attackers to guess other valid values or infer transaction volumes.",
        "Implication": "An attacker may be able to guess the location of some sensitive files. These files could do anything from reveal software versions to allow acccess to sensitive functionality.",
        "Solution": "The custom framework should enforce authentication/authorization checks on all dynamic content. Custom administrative interfaces should be built on top of generic framework administrative access platform, segregated from user interfaces.",
        "Likelihood": "LOW",
        "Impact": "LOW",
        "Risk": "LOW",
        "Types": "Web"

    },
    {
        "Name": "Buffer Overflow",
        "Description": "The application allows an attacker to supply more data than will fit in a pre-allocated block of memory and overwrite existing instructions or data.",
        "Implication": "The attacker is able to inject too much data into the application. This can lead to application crashes, or in some cases, add executable code after the buffer.",
        "Solution": "The framework should be built on a memory-managed platform which prohibits direct memory access.",
        "Likelihood": "HIGH",
        "Impact": "VERY HIGH",
        "Risk": "VERY HIGH",
        "Types": [
            "Web",
            "Thick"
        ]

    },
    {
        "Name": "Clickjacking",
        "Description": "A web application does not prevent itself from being framed into another application. This allows it to be framed into the application, and an attacker can use this to either hide the target application within an invisible frame, and pass clicks to it, or to put content on top of th",
        "Implication": "The attacker can use the invisible frame to 'pass' clicks to the target site. This can trick users into performing actions they otherwise would not, and bypass anti-CSRF nonces. If an attacker chooses to place content on top of the frame, the attacker can spoof an authentication box on top of the application, tricking users into revealing their credentials.",
        "Solution": "Apply either an X-Frame-Options header, with a value of 'DENY' or 'SAMEORIGIN'. The framework should also check the User Agent from  each request, and if the User Agent does not support X-Frame-Options or Content Security Policy, then it should either insert Framebusting code, or redirect to a Browser upgrade page. Content Security Policy is a more robust solution than X-Frame-Options, but is not yet fully standardized across all browsers.",
        "Likelihood": "MEDIUM",
        "Impact": "MEDIUM",
        "Risk": "MEDIUM",
        "Types": "Web"

    }
]
